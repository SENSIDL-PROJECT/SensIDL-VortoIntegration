modeltype SensIDLModel "strict" uses "http://fzi.de/sensidl/design/1.0";
modeltype VortoInformationModel "strict" uses "http://www.eclipse.org/vorto/metamodel/InformationModel";
modeltype VortoFunctionblock "strict" uses "http://www.eclipse.org/vorto/metamodel/Functionblock";
modeltype VortoDataTypes "strict" uses "http://www.eclipse.org/vorto/metamodel/Datatype";

transformation Vorto2SensIDLTransformation(in Source: VortoInformationModel, out Target: SensIDLModel);

main() {
	log("Start with transformation");
	
	Source.rootObjects()[VortoInformationModel::InformationModel].properties.type -> map toSensorInterface();	
	
	log("Finish transformation");
}

mapping VortoFunctionblock::FunctionblockModel::toSensorInterface() : SensIDLModel::SensorInterface {
	log("Start with SensorInterface-transformation");

	name := self.name;
	description := self.description;
	dataDescription := self.functionblock.map toDataDescription();
	encodingSettings := createDefaultSettings();
}

query createDefaultSettings() : SensIDLModel::EncodingSettings {
	return object SensIDLModel::EncodingSettings {
		coding := SensIDLModel::Coding::SENSIDL_BINARY;
		endianness := SensIDLModel::Endianness::BIG_ENDIAN;
		alignment := 1;
	};
}

mapping VortoFunctionblock::FunctionBlock::toDataDescription() : SensIDLModel::dataRepresentation::SensorDataDescription
when {self.events -> size() > 0} {
	log("Start with SensorDataDescription-transformation");
	
	self.events -> forEach(event) {
		dataSets += toDataSet(event) -> flatten();
	}
}

query toDataSet(event : VortoFunctionblock::Event) : OrderedSet(SensIDLModel::dataRepresentation::DataSet) {
	log("Start with DataSet-transformation");
	
	var DataSets : OrderedSet(SensIDLModel::dataRepresentation::DataSet);
	var DataSet : SensIDLModel::dataRepresentation::DataSet;
	
	DataSet := object SensIDLModel::dataRepresentation::DataSet {
		name := event.name;
		data := event.properties -> select(prop | prop.type.oclIsTypeOf(VortoDataTypes::PrimitivePropertyType)) 
				-> toData();
	};
	
	event.properties -> select(prop | prop.type.oclIsTypeOf(VortoDataTypes::ObjectPropertyType)) -> forEach(prop) {
		var tempDataSet := PropertyToDataSet(prop);
		DataSet.usedDataSets := tempDataSet;
		DataSets += tempDataSet;
	};
	
	DataSets += DataSet;
	
	return DataSets;
}

query PropertyToDataSet(proper : VortoDataTypes::Property) : OrderedSet(SensIDLModel::dataRepresentation::DataSet) 
//when {self.type.oclAsType(VortoDataTypes::ObjectPropertyType).type.oclIsTypeOf(VortoDataTypes::Entity)} 
{
	log("Start with DataSet-transformation");
			
	var DataSets : OrderedSet(SensIDLModel::dataRepresentation::DataSet);
	var DataSet : SensIDLModel::dataRepresentation::DataSet;
	
	DataSet := object SensIDLModel::dataRepresentation::DataSet {
		name := proper.name;
		data := proper.type.oclAsType(VortoDataTypes::ObjectPropertyType).type.oclAsType(VortoDataTypes::Entity).properties 
			-> select(prop | prop.type.oclIsTypeOf(VortoDataTypes::PrimitivePropertyType)) -> toData();
	};
	
	proper.type.oclAsType(VortoDataTypes::ObjectPropertyType).type.oclAsType(VortoDataTypes::Entity).properties
			-> select(prop | prop.type.oclIsTypeOf(VortoDataTypes::ObjectPropertyType)) -> forEach(prop) {
		var tempDataSet := PropertyToDataSet(prop);
		DataSet.usedDataSets := tempDataSet;
		DataSets += tempDataSet;
	};
	
	DataSets += DataSet;
	
	return DataSets;
}

query VortoDataTypes::Property::toData() : SensIDLModel::dataRepresentation::Data {
	var data : SensIDLModel::dataRepresentation::Data;
	
	if (isNonMeasurement(self.description)) then {
		data := self.map toNonMeasurementData();
	} else {
		data := self.map toMeasurementData();
	} endif;
	
	//log(((dataInfos -> at(0)).toString() = "1").toString());
	
	return data;
}

query isNonMeasurement(description : String) : Boolean {
	return (description.find("NonMeasurement") > 0);
}

mapping VortoDataTypes::Property::toNonMeasurementData() : SensIDLModel::dataRepresentation::NonMeasurementData {
	log("Start with MeasurementData-transformation");

	name := self.name;
	description := self.description;
	dataType := toDataType(self.type.oclAsType(VortoDataTypes::PrimitivePropertyType).type);
	
	if (hasValue(self.description)) then {
		value := self.description.replaceAll("[^0-9]*", ""); 
	} endif;
	
	if (isConstant(self.description)) then {
		constant := true;
	} endif;
}

query hasValue(description : String) : Boolean {
	return (description.find("value") > 0);
}

query isConstant(description : String) : Boolean {
	return (description.find("constant") > 0);
}

mapping VortoDataTypes::Property::toMeasurementData() : SensIDLModel::dataRepresentation::MeasurementData {
	log("Start with MeasurementData-transformation");

	name := self.name;
	description := self.description;
	dataType := toDataType(self.type.oclAsType(VortoDataTypes::PrimitivePropertyType).type);
	adjustments := map toDataRange(self.Constraints);	
	// unit := ...
}

mapping toDataRange(in constraints : OrderedSet(VortoDataTypes::Constraint)) : SensIDLModel::dataRepresentation::DataRange 
when {
	(constraints -> size() = 2) and 
	(constraints -> exists(constraint | constraint.type = VortoDataTypes::ConstraintIntervalType::min)) and
	(constraints -> exists(constraint | constraint.type = VortoDataTypes::ConstraintIntervalType::max))
} {
	range := object SensIDLModel::dataRepresentation::Interval {
		lowerBound := getCorrespondingBound(constraints, true);
		upperBound := getCorrespondingBound(constraints, false);
	}
}

//At this stage integer insteat of double values are returned.
query getCorrespondingBound(constraints : OrderedSet(VortoDataTypes::Constraint), isLowerBound : Boolean) : Integer {
	if (isLowerBound) then {
		constraints -> forEach(constraint) {
			if (constraint.type = VortoDataTypes::ConstraintIntervalType::min) then {
				return constraint.constraintValues.toInteger();
			} endif;
		};
	} endif;
	
	constraints -> forEach(constraint) {
			if (constraint.type = VortoDataTypes::ConstraintIntervalType::max) then {
				return constraint.constraintValues.toInteger();
			} endif;
	};
	
	return 0;
}

query toDataType(primType : VortoDataTypes::PrimitiveType) :  SensIDLModel::dataRepresentation::DataType {
	log("Start with DataType-transformation");
	
	if (primType = VortoDataTypes::PrimitiveType::string) then {
		return SensIDLModel::dataRepresentation::DataType::STRING;
	} endif;
	
	if (primType = VortoDataTypes::PrimitiveType::int) then {
		return SensIDLModel::dataRepresentation::DataType::INT32;
	} endif;
	
	if (primType = VortoDataTypes::PrimitiveType::float) then {
		return SensIDLModel::dataRepresentation::DataType::FLOAT;
	} endif;
	
	if (primType = VortoDataTypes::PrimitiveType::boolean) then {
		return SensIDLModel::dataRepresentation::DataType::BOOLEAN;
	} endif;
	
	if (primType = VortoDataTypes::PrimitiveType::datetime) then {
		return SensIDLModel::dataRepresentation::DataType::UNDEFINED;
	} endif;
	
	if (primType = VortoDataTypes::PrimitiveType::double) then {
		return SensIDLModel::dataRepresentation::DataType::DOUBLE;
	} endif;
	
	if (primType = VortoDataTypes::PrimitiveType::long) then {
		return SensIDLModel::dataRepresentation::DataType::INT64;
	} endif;
	
	if (primType = VortoDataTypes::PrimitiveType::short) then {
		return SensIDLModel::dataRepresentation::DataType::INT16;
	} endif;
	
	if (primType = VortoDataTypes::PrimitiveType::base64Binary) then {
		return SensIDLModel::dataRepresentation::DataType::UNDEFINED;
	} endif;
	
	if (primType = VortoDataTypes::PrimitiveType::byte) then {
		return SensIDLModel::dataRepresentation::DataType::UINT8;
	} endif;
	
	return return SensIDLModel::dataRepresentation::DataType::UNDEFINED;
}