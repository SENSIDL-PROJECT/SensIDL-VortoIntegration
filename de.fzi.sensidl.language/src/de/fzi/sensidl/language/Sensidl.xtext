/**
 * Die Grammatik für die SensIDL-Sprache.
 * Das zugehörige Metamodell kann unter de.fzi.sensidl.design/model/sensIDL.ecore
 * gefunden werden.
 * @author Dominik Werle
 * @author Max Scheerer
 * @author Emre Taspolatoglu
 */

grammar de.fzi.sensidl.language.Sensidl with org.eclipse.xtext.common.Terminals 

// use a manually specified metamodel instead of generating one from the Xtext grammar
//import "platform:/resource/de.fzi.sensidl.design/model/sensIDL.ecore" as sensidl
import "http://www.eclipse.org/emf/2002/Ecore" as ecore 
import "http://fzi.de/sensidl/design/1.0" as sensidl
import "http://fzi.de/sensidl/design/representation/1.0" as dataRepresentation

NamedElement returns sensidl::NamedElement:
	SensorInterface | 
	SensorDataDescription |
	DataSet |
	Data
;

SensorInterface returns sensidl::SensorInterface: 
	"sensorInterface" name=ID (description=STRING)? ("with" "identifier" ID=STRING)? "{"
		metaInformation=SensorMetaInformation
		dataDescription=SensorDataDescription
	"}"";"
;

SensorMetaInformation returns sensidl::SensorMetaInformation: 
	"encoding" coding=Coding "with" endianness=Endianness "alignment" alignment=Alignment ";"
;

enum Alignment returns sensidl::Alignment: 
	_8BIT | _16BIT | _32BIT | _64BIT
;

enum Coding returns sensidl::Coding:
	SENSIDL_BINARY | SENSIDL_JSON
;

enum Endianness returns sensidl::Endianness:
	BIG_ENDIAN | LITTLE_ENDIAN
;

SensorDataDescription returns dataRepresentation::SensorDataDescription:
	"sensorData" name=ID (description=STRING)? ("with" "identifier" ID=STRING)? "{"
		(dataSets+=DataSet)*
	"}"";"
;

DataSet returns dataRepresentation::DataSet:
	"dataSet" name=ID (description=STRING)? ("with" "identifier" ID=STRING)? "{"		
		(subDataSets+=DataSet)?
		(data+=Data)*
	"}"";"
;

Data  returns dataRepresentation::Data:
	MeasurementData |
	NonMeasurementData
;

MeasurementData  returns dataRepresentation::MeasurementData:
	name=ID "as" dataType=DataType "in" unit=UNIT ("with" "identifier" ID=STRING)?
	("adjusted" "by" ":" adjustments+=DataAdjustement ("," adjustments+=DataAdjustement)*)? (description=STRING)? ";"
;

NonMeasurementData  returns dataRepresentation::NonMeasurementData:
	name=ID "as" dataType=DataType "constant""=" constant=BOOLEAN "value""=" value=STRING ("with" "identifier" ID=STRING)? (description=STRING)? ";"
;

enum DataType   returns dataRepresentation::DataType:
	SIGNED_CHAR |
	UNSIGNED_CHAR |
	SIGNED_SHORT |
	UNSIGNED_SHORT |
	SIGNED_LONG |
	UNSIGNED_LONG |
	SIGNED_LONG_LONG |
	UNSIGNED_LONG_LONG |
	FLOAT |
	DOUBLE |
	LONG_DOUBLE
;

DataAdjustement  returns dataRepresentation::DataAdjustment:
	DataRange |
	DataConversion
;

DataRange  returns dataRepresentation::DataRange:
	"with" "range" range=Interval";"
;

Interval  returns dataRepresentation::Interval:
	lowerBound=DOUBLE"..."upperBound=DOUBLE
;

DataConversion  returns dataRepresentation::DataConversion:
	LinearDataConversion
;

LinearDataConversion  returns dataRepresentation::LinearDataConversion:	
	(
		"with" "scaling factor"":" scalingFactor=DOUBLE "and" "offset"":"offset=DOUBLE |
		"linear mapping" "[" fromInterval=Interval"]" "=>" "["toInterval=Interval"]" 
	)
;

DOUBLE returns ecore::EDouble: INT ('.' INT)?;
BOOLEAN returns ecore::EBoolean: 'true' | 'false';
//UNIT returns dataRepresentation::Unit: STRING;
terminal UNIT returns dataRepresentation::Unit : '^'?('a'..'z'|'A'..'Z'/**'_'*/) ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
