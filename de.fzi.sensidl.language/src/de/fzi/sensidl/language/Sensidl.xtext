/**
 * Die Grammatik für die SensIDL-Sprache.
 * Das zugehörige Metamodell kann unter de.fzi.sensidl.design/models/sensIDL.ecore
 * gefunden werden.
 * @author Dominik Werle
 * @author Max Scheerer
 */

grammar de.fzi.sensidl.language.Sensidl with org.eclipse.xtext.common.Terminals 

// use a manually specified metamodel instead of generating one from the Xtext grammar
//import "platform:/resource/de.fzi.sensidl.design/model/sensIDL.ecore"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore 
import "http://fzi.de/sensidl/design/1.0" as sensidl
import "http://fzi.de/sensidl/design/representation/1.0" as dataRepresentation
import "http://fzi.de/sensidl/design/transmission/1.0" as dataTransmission

NamedElement returns sensidl::NamedElement:
	SensorInterface | 
	SensorDataDescription |
	DataSet |
	Data |
	SensorDataTransmission	 
;

SensorInterface returns sensidl::SensorInterface: 
	"Sensor" name=ID (description=STRING)? ("with" "identifier" ID=STRING)? "{"
		metaInformation=SensorMetaInformation
		dataDescription=SensorDataDescription
		dataTransmission=SensorDataTransmission
	"}"";"
;

SensorMetaInformation returns sensidl::SensorMetaInformation: 
	"encoding" coding=Coding "with" endianness=Endianness "alignment" alignment=Alignment
;

enum Alignment returns sensidl::Alignment: 
	_8BIT | _16BIT | _32BIT | _64BIT
;

enum Coding returns sensidl::Coding:
	SENSIDL_BINARY | SENSIDL_JSON
;

enum Endianness returns sensidl::Endianness:
	BIG_ENDIAN | LITTLE_ENDIAN
;

SensorDataDescription returns dataRepresentation::SensorDataDescription:
	"SensorData" name=ID (description=STRING)? ("with" "identifier" ID=STRING)? "{"
		sets+=DataSet
	"}"";"
;

DataSet returns dataRepresentation::DataSet:
	"MeasuredData" name=ID (description=STRING)? ("with" "identifier" ID=STRING)? "{"		
		sets+=DataSet
		data+=Data 
	"}"";"
;

Data  returns dataRepresentation::Data:
	MeasurementData |
	NonMeasurementData
;

MeasurementData  returns dataRepresentation::MeasurementData:
	name=ID "as" dataType=DataType "in" unit=UNIT (description=STRING)? ("with" "identifier" ID=STRING)?";"
	("Adjusted" "by" ":" adjustments+=DataAdjustement ("," adjustments+=DataAdjustement)*)?
;

NonMeasurementData  returns dataRepresentation::NonMeasurementData:
	name=ID "as" dataType=DataType "constant""=" constant=BOOLEAN "value" value=STRING (description=STRING)? ("with" "identifier" ID=STRING)?";"
;

enum DataType   returns dataRepresentation::DataType:
	SIGNED_CHAR |
	UNSIGNED_CHAR |
	SIGNED_SHORT |
	UNSIGNED_SHORT |
	SIGNED_LONG |
	UNSIGNED_LONG |
	SIGNED_LONG_LONG |
	UNSIGNED_LONG_LONG |
	FLOAT |
	DOUBLE |
	LONG_DOUBLE
;

DataAdjustement  returns dataRepresentation::DataAdjustment:
	DataRange |
	DataConversion
;

DataRange  returns dataRepresentation::DataRange:
	"with" "range" range=Interval";"
;

Interval  returns dataRepresentation::Interval:
	lowerBound=DOUBLE"..."upperBound=DOUBLE
;

DataConversion  returns dataRepresentation::DataConversion:
	LinearDataConversion
;

LinearDataConversion  returns dataRepresentation::LinearDataConversion:	
	(
		"with" "scaling factor"":" scalingFactor=DOUBLE "and" "offset"":"offset=DOUBLE |
		"map linear" "[" fromInterval=Interval"]" "=>" "["toInterval=Interval"]" 
	)";"
;

SensorDataTransmission  returns dataTransmission::SensorDataTransmission:
	"DataTransmission" name=ID (description=STRING)? ("with" "identifier" ID=STRING)?
;

DOUBLE returns ecore::EDouble: INT ('.' INT)?;
BOOLEAN returns ecore::EBoolean: 'true' | 'false';
UNIT returns dataRepresentation::Unit : STRING;
