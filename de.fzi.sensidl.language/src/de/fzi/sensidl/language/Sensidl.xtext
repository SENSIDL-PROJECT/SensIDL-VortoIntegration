/**
 * Die Grammatik für die SensIDL-Sprache.
 * Das zugehörige Metamodell kann unter de.fzi.sensidl.design/models/sensIDL.ecore
 * gefunden werden.
 * @author Dominik Werle
 */

grammar de.fzi.sensidl.language.Sensidl with org.eclipse.xtext.common.Terminals

// use a manually specified metamodel instead of generating one from the Xtext grammar
import "platform:/resource/de.fzi.sensidl.design/models/sensIDL.ecore"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DataModel:
	"options" "{"
		options=Options
	"}"
	
	(
		(representations += Representation) |
	 	(interpretations += Interpretation)
	)*
	
	"transmit" transmit+=[Interpretation]
		("," transmit+=[Interpretation])*
;

Options:
	{Options}
	(
		("transmission" "type" ":" transmissionType=Transmission) |
		("sensor" "language" ":" sensorLanguage=GenerationLanguage) |
		("receiver" "language" ":" receiverLanguage=GenerationLanguage)
	)*
;

/**
 * Übertragungsmöglichkeit durch Pull oder Push.
 */
Transmission:
	Pull |
	Push
;

/**
 * Mit "methodName" kann nach Aufforderung auf der Empfängerseite "gepusht" werden.
 * Optional kann mit "frequency" (in Hz) "gepusht" werden.
 */
Push:
	"push"
	("with" "Frequency" ":" frequency=INT "and")?
	"with" methodName = ID
;

/**
 * Mit "frequency" (Hz) wird angegeben, wie häufig "gepullt" werden soll. 
 */
Pull:
	(TimeDivisionMultiplexing) |
	"pull"
	"with" "Frequency" ":" frequency=INT
;

/**
 * Spezialfall von Push.
 * "frequency" wie bei pull und push
 * Mit "duration" wird die Übertragungsdauer angegeben.
 * Mit "timeSlot" wird der genaue Zeitpunkt angegeben wenn mit Dauer "duration" übertragen werden kann. 
 */
TimeDivisionMultiplexing:
	"timeDivisionMultiplexing"
	"with" "Frequency" ":" frequency=INT
	"and" "Duration" ":" duration=DOUBLE
	"and" "timeSlot" ":" timeSlot=DOUBLE
;

enum GenerationLanguage:
	JAVA | CPP | C | CSHARP
;

Representation:
	("repr" | "representation") name=ID
	"is" type=Type
	"by" byteCount=INT ("bytes" | "byte") 
;

Interpretation:
	Constant |
	PrimitiveInterpretation |
	Measurement |
	InterpretationGroup |
	Calculated
;

Calculated:
	("calculate" | "calculated")
	name=ID
	"as" representation=[Representation]
	"by" methodName=ID ("," methodNameOut=ID)?
	"with" parameter+=Parameter ("," parameter+=Parameter)*
;

Parameter:
	"("
		interpretation=[Interpretation]
		("as" argumentType=ArgumentType)?
	")"
;

InterpretationGroup:
	"group" name=ID "{"
		(interpretations+=Interpretation)*
	"}"
;

/*
 * Einheiten noch als String
 */
Measurement:
	"measurement" "of"
	quantity=Quantity
	name=ID
	"in" (scale=DOUBLE)? unit=STRING
	"as" representation=[Representation]
	(constraints+=MeasurementConstraint)*
;

MeasurementConstraint:
	MeasurementInRange |
	MeasurementAdaption
;

MeasurementInRange:
	"from" lowerBound=Measure
	"to" upperBound=Measure
;

/**
 * Konkrete Fall eines MeasurementConstraints.
 * Wertadaption durch Skalierungsfaktor "scalingFactor" und dem Offset "offset".
 */
MeasurementAdaption:
	"with" "scaling factor" ":" scalingFactor=DOUBLE
	"and" "offset" ":" offset=DOUBLE 
;


/*
 * Einheiten noch als String
 */
Measure:
	value=DOUBLE unit=STRING
;


PrimitiveInterpretation:
	"primitive" type=Type name=ID
	"as" representation=[Representation]
;

Constant:
	"constant" name=ID
	"as" representation=[Representation]
	"is" constantValue=STRING
;

DOUBLE returns ecore::EDouble: INT ('.' INT)?;

/*
 * Die EEnums und EEnumLiterals können direkt so ausgedrückt werden.
 */
enum ArgumentType:
	BYTE_ARRAY 
;

enum Quantity:
	FLOW | TEMPERATURE | VOLUME | DURATION | PRESSURE | ELECTRICENERGY
;

enum Type:
	BYTE | SHORT | INT | LONG | FLOAT | DOUBLE
;