/**
 * Die Grammatik für die SensIDL-Sprache.
 * Das zugehörige Metamodell kann unter de.fzi.sensidl.design/models/sensIDL.ecore
 * gefunden werden.
 * @author Dominik Werle
 * @author Max Scheerer
 */

grammar de.fzi.sensidl.language.Sensidl with org.eclipse.xtext.common.Terminals

// use a manually specified metamodel instead of generating one from the Xtext grammar
import "platform:/resource/de.fzi.sensidl.design/models/sensIDL.ecore"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DataModel:
	"datamodel" "{"
		"options" "{"
			options=Options
		"}"
		
		(
			(representations += Representation) |
		 	(datafields += Datafield)
		)*
		
		"transmit" transmit+=[Datafield]
			("," transmit+=[Datafield])*
	"}"
;

Options:
	{Options}
	(
		("endianess" ":" endianess=Endianess";")
		("sensor" "options" ":")
		("sensor" "language" ":" sensorLanguage=GenerationLanguage";")
		("sensor" "alignment" ":" sensorAlignment=Alignment";") 
		("receiver" "options" ":")
		("receiver" "language" ":" receiverLanguage=GenerationLanguage";")
		("receiver" "alignment" ":" receiverAlignment=Alignment";")
	)
;

enum Alignment:
	_8BIT | _16BIT | _32BIT | _64BIT
;

enum Endianess:
	BIG_ENDIAN | LITTLE_ENDIAN
;

enum GenerationLanguage:
	JAVA | CPP | C | CSHARP
;

NamedElement: 
	Representation |
	Datafield |
	Constraint 
;


Representation:
	("repr" | "representation") name=ID
	"is" byteCount=INT ("bytes" | "byte")
	"in" type=Type
	("description" ":" description=STRING)?
	("id" ":" ID=STRING)?
	";"
;

Datafield:
	VariableData |
	ConstantData |
	Datastructure |
	Declaration |
	Calculated 
;

VariableData:
	 MeasuredData |
	 NonMeasuredData
;

MeasuredData: 
	"data" "of"
	name=ID
	("in" (scale=DOUBLE)? unit=STRING)?
	"as" representation=[Representation]
	("description" ":" description=STRING)?
	("id" ":" ID=STRING)? 
	(constraints+=DataConstraint)*
	";"
;

NonMeasuredData: 
	"basicdata" type=Type name=ID
	"as" representation=[Representation]
	("description" ":" description=STRING)? 
	("id" ":" ID=STRING)?
	";"
;


ConstantData: 
	"const" name=ID
	"as" representation=[Representation]
	("is" constValue=STRING)?
	("description" ":" description=STRING)?
	("id" ":" ID=STRING)?
	";"
;

Calculated:
	("calculate" | "calculated")
	name=ID
	"as" representation=[Representation]
	"by" methodName=ID ("," methodNameOut=ID)?
	"with" parameter+=Parameter ("," parameter+=Parameter)*
	("description" ":" description=STRING)?
	("id" ":" ID=STRING)?
	";"
;

Parameter:
	"("
		datafield=[Datafield]
		("as" argumentType=ArgumentType)?
	")"
;

Datastructure:
	"set" name=ID "{"
		(datafields+=Datafield)*
		("description" ":" description=STRING)?
		("id" ":" ID=STRING)?
	"}"";"
;

Declaration: 
	("declaration"|"decl") declarations+=DatastructureDeclaration ("," declarations+=DatastructureDeclaration)*";"
;


DatastructureDeclaration: 
	reusedDatastructure=[Datastructure] name=ID
;

Constraint: 
	DataConstraint
;


DataConstraint: 
	DataRange |
	DataAdaption
;

DataRange: 
	"from" lowerBound=Bound
	"to" upperBound=Bound
	("description" ":" description=STRING)?
	("id" ":" ID=STRING)?
;

/**
 * Konkrete Fall eines MeasurementConstraints.
 * Wertadaption durch Skalierungsfaktor "scalingFactor" und dem Offset "offset".
 */
DataAdaption: 
	"with" "scaling factor" ":" scalingFactor=DOUBLE
	"and" "offset" ":" offset=DOUBLE
	("description" ":" description=STRING)?
	("id" ":" ID=STRING)? 
;


/*
 * Einheiten noch als String
 */
Bound: 
	value=DOUBLE (unit=STRING)?
;

DOUBLE returns ecore::EDouble: INT ('.' INT)?;

/*
 * Die EEnums und EEnumLiterals können direkt so ausgedrückt werden.
 */
enum ArgumentType:
	BYTE_ARRAY 
;

enum Type:
	BOOL | CHAR | SHORT | INT | LONG | LONGLONG | FLOAT | DOUBLE | LONGDOUBLE
;