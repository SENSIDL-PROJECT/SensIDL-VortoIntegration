/**
 * Die Grammatik für die SensIDL-Sprache.
 * Das zugehörige Metamodell kann unter de.fzi.sensidl.design/models/sensIDL.ecore
 * gefunden werden.
 * @author Dominik Werle
 */

grammar de.fzi.sensidl.language.Sensidl with org.eclipse.xtext.common.Terminals

// use a manually specified metamodel instead of generating one from the Xtext grammar
import "platform:/resource/de.fzi.sensidl.design/models/sensIDL.ecore"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

DataModel:
	"datamodel" "{"
		"options" "{"
			options=Options
		"}"
		
		(
			(representations += Representation) |
		 	(datafields += Datafield)
		)*
		
		"transmit" transmit+=[Datafield]
			("," transmit+=[Datafield])*
	"}"
;

Options:
	{Options}
	(
		("sensor" "language" ":" sensorLanguage=GenerationLanguage) |
		("receiver" "language" ":" receiverLanguage=GenerationLanguage)
	)*
;

enum GenerationLanguage:
	JAVA | CPP | C | CSHARP
;

Representation:
	("repr" | "representation") name=ID
	"is" byteCount=INT ("bytes" | "byte")
	"in" type=Type
;

Datafield:
	Metadata |
	Data |
	Datastructure |
	Calculated
;

Calculated:
	("calculate" | "calculated")
	name=ID
	"as" representation=[Representation]
	"by" methodName=ID ("," methodNameOut=ID)?
	"with" parameter+=Parameter ("," parameter+=Parameter)*
;

Parameter:
	"("
		datafield=[Datafield]
		("as" argumentType=ArgumentType)?
	")"
;

Datastructure: 
	"structure" name=ID "{"
		(datafields+=Datafield)*
	"}"
;

/*
 * Einheiten noch als String
 */
Data: 
	"data" "of"
	name=ID
	("in" (scale=DOUBLE)? unit=STRING)?
	"as" representation=[Representation]
	("with" "bit" "numbering" bitNumbering=BitNumbering)? 
	(constraints+=DataConstraint)*
;

DataConstraint: 
	DataRange |
	DataAdaption
;

DataRange: 
	"from" lowerBound=Bound
	"to" upperBound=Bound
;

/**
 * Konkrete Fall eines MeasurementConstraints.
 * Wertadaption durch Skalierungsfaktor "scalingFactor" und dem Offset "offset".
 */
DataAdaption: 
	"with" "scaling factor" ":" scalingFactor=DOUBLE
	"and" "offset" ":" offset=DOUBLE 
;


/*
 * Einheiten noch als String
 */
Bound: 
	value=DOUBLE unit=STRING
;


Metadata: 
	"primitive" type=Type name=ID
	"as" representation=[Representation]
;

DOUBLE returns ecore::EDouble: INT ('.' INT)?;

/*
 * Die EEnums und EEnumLiterals können direkt so ausgedrückt werden.
 */
enum ArgumentType:
	BYTE_ARRAY 
;

enum Type:
	BOOL | CHAR | SHORT | INT | LONG | LONGLONG | FLOAT | DOUBLE | LONGDOUBLE
;

enum BitNumbering:
	LSB | MSB
;